use starknet::ContractAddress;

// Defining the interface here ensures Dispatchers are generated in the current scope
#[starknet::interface]
pub trait IERC20<TContractState> {
    fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        ref self: TContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256,
    ) -> bool;
    fn allowance(self: @TContractState, owner: ContractAddress, spender: ContractAddress) -> u256;
}

#[starknet::contract]
mod ProofOfLife {
    use contract::interface::IProofOfLife;
    use contract::types::{AssetConfig, Heir};
    use starknet::storage::{Map, StorageMapReadAccess, StorageMapWriteAccess};
    use starknet::{ContractAddress, get_block_timestamp, get_caller_address, get_contract_address};

    // Import the Dispatchers generated by the interface above
    use super::{IERC20Dispatcher, IERC20DispatcherTrait};

    #[storage]
    struct Storage {
        last_pulse: Map<ContractAddress, u64>,
        inactivity_threshold: Map<ContractAddress, u64>,
        heirs_count: Map<ContractAddress, u32>,
        heirs: Map<(ContractAddress, u32), Heir>,
        user_assets_count: Map<ContractAddress, u32>,
        user_assets: Map<(ContractAddress, u32), AssetConfig>,
        vault_balances: Map<(ContractAddress, ContractAddress), u256>,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        Pulse: Pulse,
        SwitchSetup: SwitchSetup,
        AssetRegistered: AssetRegistered,
        Deposit: Deposit,
        InheritanceClaimed: InheritanceClaimed,
        Distributed: Distributed,
        Withdrawal: Withdrawal,
    }

    #[derive(Drop, starknet::Event)]
    struct Pulse {
        #[key]
        owner: ContractAddress,
        timestamp: u64,
    }
    #[derive(Drop, starknet::Event)]
    struct SwitchSetup {
        #[key]
        owner: ContractAddress,
        threshold: u64,
    }
    #[derive(Drop, starknet::Event)]
    struct AssetRegistered {
        #[key]
        owner: ContractAddress,
        #[key]
        token: ContractAddress,
    }
    #[derive(Drop, starknet::Event)]
    struct Deposit {
        #[key]
        owner: ContractAddress,
        #[key]
        token: ContractAddress,
        amount: u256,
    }
    #[derive(Drop, starknet::Event)]
    struct InheritanceClaimed {
        #[key]
        owner: ContractAddress,
        #[key]
        claimant: ContractAddress,
    }
    #[derive(Drop, starknet::Event)]
    struct Distributed {
        #[key]
        owner: ContractAddress,
        #[key]
        token: ContractAddress,
        #[key]
        heir: ContractAddress,
        amount: u256,
    }

    #[derive(Drop, starknet::Event)]
    struct Withdrawal {
        #[key]
        owner: ContractAddress,
        #[key]
        token: ContractAddress,
        amount: u256,
    }

    #[abi(embed_v0)]
    impl ProofOfLifeImpl of IProofOfLife<ContractState> {
        fn on_execute(ref self: ContractState, account: ContractAddress) {
            let now = get_block_timestamp();
            self.last_pulse.write(account, now);
            self.emit(Pulse { owner: account, timestamp: now });
        }

        fn withdraw(ref self: ContractState, token: ContractAddress, amount: u256) {
            let owner = get_caller_address();

            // 1. Safety Check: Only the owner can withdraw while they are active
            assert(!self.is_dead(owner), 'Owner is dead: use inheritance');

            // 2. Balance Check
            let current_bal = self.vault_balances.read((owner, token));
            assert(current_bal >= amount, 'Insufficient vault balance');

            // 3. State Update
            self.vault_balances.write((owner, token), current_bal - amount);

            // 4. Actual Transfer
            IERC20Dispatcher { contract_address: token }.transfer(owner, amount);

            // We can reuse the Pulse logic here because withdrawing is a sign of life!
            self.heartbeat();

            self.emit(Withdrawal { owner, token, amount });
        }

        fn emergency_withdraw_all(ref self: ContractState, token: ContractAddress) {
            let owner = get_caller_address();
            let amount = self.vault_balances.read((owner, token));

            assert(amount > 0, 'No balance to withdraw');

            // Reuse the withdraw logic for consistency
            self.withdraw(token, amount);
        }

        fn heartbeat(ref self: ContractState) {
            let caller = get_caller_address();
            let now = get_block_timestamp();
            self.last_pulse.write(caller, now);
            self.emit(Pulse { owner: caller, timestamp: now });
        }

        fn setup_switch(ref self: ContractState, threshold: u64, heirs: Array<Heir>) {
            let owner = get_caller_address();
            self.inactivity_threshold.write(owner, threshold);

            let len = heirs.len();
            self.heirs_count.write(owner, len);

            let mut i: u32 = 0;
            while i < len {
                self.heirs.write((owner, i), *heirs.at(i));
                i += 1;
            }

            self.last_pulse.write(owner, get_block_timestamp());
            self.emit(SwitchSetup { owner, threshold });
        }

        fn register_asset(ref self: ContractState, asset: AssetConfig) {
            let owner = get_caller_address();
            let count = self.user_assets_count.read(owner);
            self.user_assets.write((owner, count), asset);
            self.user_assets_count.write(owner, count + 1);

            self.emit(AssetRegistered { owner, token: asset.token_address });
        }

        fn deposit(ref self: ContractState, token: ContractAddress, amount: u256) {
            let caller = get_caller_address();
            IERC20Dispatcher { contract_address: token }
                .transfer_from(caller, get_contract_address(), amount);

            let current = self.vault_balances.read((caller, token));
            self.vault_balances.write((caller, token), current + amount);

            self.emit(Deposit { owner: caller, token, amount });
        }

        fn claim_inheritance(ref self: ContractState, owner: ContractAddress) {
            let last_pulse = self.last_pulse.read(owner);
            let threshold = self.inactivity_threshold.read(owner);

            // 1. Core Inactivity Checks
            assert(last_pulse != 0, 'Not initialized');
            assert(get_block_timestamp() > last_pulse + threshold, 'Owner still active');

            // 2. Authorization Check (New!)
            let caller = get_caller_address();
            assert(self._is_heir(owner, caller), 'Unauthorized: Not an heir');

            self.emit(InheritanceClaimed { owner, claimant: caller });

            let asset_count = self.user_assets_count.read(owner);
            let heir_count = self.heirs_count.read(owner);

            let mut i: u32 = 0;
            while i < asset_count {
                let asset = self.user_assets.read((owner, i));

                let v_bal = self.vault_balances.read((owner, asset.token_address));
                if v_bal > 0 {
                    self._distribute_vault(owner, asset.token_address, v_bal, heir_count);
                }

                let allow = IERC20Dispatcher { contract_address: asset.token_address }
                    .allowance(owner, get_contract_address());
                if allow > 0 {
                    self._distribute_allowance(owner, asset.token_address, allow, heir_count);
                }
                i += 1;
            };
        }

        fn get_last_pulse(self: @ContractState, user: ContractAddress) -> u64 {
            self.last_pulse.read(user)
        }

        fn is_dead(self: @ContractState, user: ContractAddress) -> bool {
            let lp = self.last_pulse.read(user);
            let threshold = self.inactivity_threshold.read(user);
            if lp == 0 {
                return false;
            }
            get_block_timestamp() > lp + threshold
        }
    }

    #[generate_trait]
    impl InternalFunctions of InternalFunctionsTrait {
        fn _distribute_vault(
            ref self: ContractState,
            owner: ContractAddress,
            token_addr: ContractAddress,
            amount: u256,
            heir_count: u32,
        ) {
            let mut i: u32 = 0;
            while i < heir_count {
                let heir = self.heirs.read((owner, i));
                let share = (amount * heir.percentage.into()) / 10000_u256;
                IERC20Dispatcher { contract_address: token_addr }.transfer(heir.address, share);

                self
                    .emit(
                        Distributed { owner, token: token_addr, heir: heir.address, amount: share },
                    );
                i += 1;
            }
            self.vault_balances.write((owner, token_addr), 0);
        }

        fn _is_heir(
            self: @ContractState, owner: ContractAddress, claimant: ContractAddress,
        ) -> bool {
            let count = self.heirs_count.read(owner);
            let mut i: u32 = 0;
            let mut found = false;

            while i < count {
                let heir = self.heirs.read((owner, i));
                if heir.address == claimant {
                    found = true;
                    break;
                }
                i += 1;
            }
            found
        }

        fn _distribute_allowance(
            ref self: ContractState,
            owner: ContractAddress,
            token_addr: ContractAddress,
            amount: u256,
            heir_count: u32,
        ) {
            let mut i: u32 = 0;
            while i < heir_count {
                let heir = self.heirs.read((owner, i));
                let share = (amount * heir.percentage.into()) / 10000_u256;
                IERC20Dispatcher { contract_address: token_addr }
                    .transfer_from(owner, heir.address, share);

                self
                    .emit(
                        Distributed { owner, token: token_addr, heir: heir.address, amount: share },
                    );
                i += 1;
            };
        }
    }
}
